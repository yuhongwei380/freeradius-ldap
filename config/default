######################################################################
server default {
listen {
	type = auth
	ipaddr = *
	port = 0
	limit {
		max_connections = 16
		lifetime = 0
		idle_timeout = 30
	}
}

listen {
	ipaddr = *
	port = 0
	type = acct
	limit {
	}
}

listen {
	type = auth
	ipv6addr = ::
	port = 0
	limit {
		max_connections = 16
		lifetime = 0
		idle_timeout = 30
	}
}

listen {
	ipv6addr = ::
	port = 0
	type = acct
	limit {
	}
}

authorize {


	# 用户名合法性过滤
	filter_username

	# 预处理
	preprocess

	# CHAP/MS-CHAP 检测
	chap
	mschap

	# 若需要 SIP digest
	digest

	# 先查询 LDAP，拿到用户 DN / 属性（只保留这一次调用）
	ldap

	# 有明文口令（PAP/TTLS/PAP/PEAP-GTC）且未设置认证类型时，强制走 LDAP 简单绑定
	if ((ok || updated) && User-Password && !control:Auth-Type) {
		update control {
			Auth-Type := LDAP
		}
	}

	# 域后缀处理
	suffix

	# EAP 初始握手早退（无 EAP-Message 时为 noop）
	eap {
		ok = return
#		updated = return
	}

	# users 文件
	files

	# SQL（如未使用保持注释）
	-sql

	# 过期与时段控制
	expiration
	logintime

	# 关键：防止 PAP 将 Password-With-Header 改写成 Cleartext-Password 并抢流
	if (&control:Password-With-Header) {
		update control {
			Password-With-Header !* ANY
		}
	}

	# 最后交给 PAP（若上面未设 Auth-Type 或其他模块未占用认证）
	pap

	Autz-Type New-TLS-Connection {
		ok
	}
}

authenticate {
	Auth-Type PAP {
		pap
	}

	Auth-Type CHAP {
		chap
	}

	Auth-Type MS-CHAP {
		mschap
	}

	# 旧配置兼容
	mschap

	# Digest 认证（如需要）
	digest

	# 简单绑定：当 authorize 段设定了 Auth-Type = LDAP 时走这里（完成预认证）
	Auth-Type LDAP {
		ldap
	}

	# 允许 EAP
	eap
}

preacct {
	preprocess
	acct_unique
	suffix
	files
}

accounting {
	detail
	unix
	-sql
	exec
	attr_filter.accounting_response
}

session {
#	radutmp
#	sql
}

post-auth {
	if (session-state:User-Name && reply:User-Name && request:User-Name && (reply:User-Name == request:User-Name)) {
		update reply {
			&User-Name !* ANY
		}
	}
	update {
		&reply: += &session-state:
	}

	-sql
	exec
	remove_reply_message_if_eap

	Post-Auth-Type REJECT {
		-sql
		attr_filter.access_reject
		eap
		remove_reply_message_if_eap
	}

	Post-Auth-Type Challenge {
#		remove_reply_message_if_eap
#		attr_filter.access_challenge.post-auth
	}

	Post-Auth-Type Client-Lost {
#		%{debug_attr:&session-state:TLS-Session-Information[*]}
#		%{debug_attr:&session-state:TLS-Session-Information[n]}
#		%{debug_attr:&session-state:Module-Failure-Message}
	}

	if (EAP-Key-Name && &reply:EAP-Session-Id) {
		update reply {
			&EAP-Key-Name := &reply:EAP-Session-Id
		}
	}
}

pre-proxy {
#	operator-name
#	cui
#	files
#	attr_filter.pre-proxy
#	pre_proxy_log
}

post-proxy {
#	post_proxy_log
#	attr_filter.post-proxy
	eap
#	Post-Proxy-Type Fail-Accounting {
#			detail.example.com
#	}
}
}
